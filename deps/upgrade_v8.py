#!/usr/bin/env python3

import urllib.request
import sys
import json
import subprocess
import os
import fnmatch
import pathlib
import shutil

vendor_file_template = """// Generated by deps/upgrade_v8.py, DO NOT REMOVE/EDIT MANUALLY.
// Package %s is required to provide support for vendoring modules
package %s
"""

include_vendor_file_template = """// Generated by deps/upgrade_v8.py, DO NOT REMOVE/EDIT MANUALLY.
// Package include is required to provide support for vendoring modules
package include

import (
\t%s
)
"""

CHROME_VERSIONS_URL = "https://chromiumdash.appspot.com/fetch_releases?channel=Stable&platform=Linux&num=1&offset=0"
V8_VERSION_FILE = "v8_version"

deps_path = os.path.dirname(os.path.realpath(__file__))
v8go_path = os.path.abspath(os.path.join(deps_path, os.pardir))
env = os.environ.copy()
v8_path = os.path.join(deps_path, "v8")
v8_include_path = os.path.join(v8_path, "include")
deps_include_path = os.path.join(deps_path, "include")

def get_directories_names(path):
  flist = []
  for p in pathlib.Path(path).iterdir():
    if p.is_dir():
        flist.append(p.name)
  return sorted(flist)

def get_module_name():
  gomod = subprocess.check_output(["go", "mod", "edit", "-print"], cwd=deps_path, env=env).decode('utf-8')
  return [line.split(" ")[1].strip() for line in gomod.strip().splitlines() if line.startswith("module ")][0]

def package_name(module, package, index, total):
  name = f'_ "{module}/deps/include/{package}"'
  if index + 1 == total:
    return name
  else:
    return name + '\n'

def create_include_vendor_file(src_path, directories, module):
  package_names = []
  total_directories = len(directories)

  for index, directory_name in enumerate(directories):
    package_names.append(package_name(module, directory_name, index, total_directories))

  with open(os.path.join(src_path, 'vendor.go'), 'w') as temp_file:
      temp_file.write(include_vendor_file_template % ('\t'.join(package_names)))

def create_vendor_files(src_path, module):
  directories = get_directories_names(src_path)

  create_include_vendor_file(src_path, directories, module)

  for directory in directories:
    directory_path = os.path.join(src_path, directory)

    vendor_go_file_path = os.path.join(directory_path, 'vendor.go')

    if os.path.isfile(vendor_go_file_path):
      continue

    with open(os.path.join(directory_path, 'vendor.go'), 'w') as temp_file:
      temp_file.write(vendor_file_template % (directory, directory))

def update_v8_version_file(src_path, version):
  with open(os.path.join(src_path, V8_VERSION_FILE), "w") as v8_file:
    print(version, file=v8_file)

def read_v8_version_file(src_path):
  v8_version_file = open(os.path.join(src_path, V8_VERSION_FILE), "r")
  return v8_version_file.read().strip()

def get_latest_v8_hash():
  with urllib.request.urlopen(CHROME_VERSIONS_URL) as response:
   json_response = response.read()
   return json.loads(json_response)[0]["hashes"]["v8"]

def get_v8_version_tag():
  tags = subprocess.check_output(["git", "tag", "--points-at", latest_stable_v8_hash], cwd=v8_path, env=env).decode('utf-8')
  return tags.splitlines()[0]

module = get_module_name()
current_v8_hash_installed = read_v8_version_file(deps_path)
latest_stable_v8_hash = get_latest_v8_hash()

if current_v8_hash_installed != latest_stable_v8_hash:
  subprocess.check_call(["git", "fetch", "origin", latest_stable_v8_hash],
                        cwd=v8_path,
                        env=env)
  latest_stable_v8_version = get_v8_version_tag()
  subprocess.check_call(["git", "-c", "advice.detachedHead=false", "checkout", latest_stable_v8_version],
                        cwd=v8_path,
                        env=env)

  shutil.rmtree(deps_include_path)
  shutil.copytree(v8_include_path, deps_include_path, dirs_exist_ok=True)
  create_vendor_files(deps_include_path, module)
  update_v8_version_file(deps_path, latest_stable_v8_hash)
